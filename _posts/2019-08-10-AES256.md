---
layout:            post
title:             "AES256방식을 통한 data 암호화/복호화(소스)"
menutitle:         "AES256방식을 통한 data 암호화/복호화(소스)"
tags:              AES256
category:          Java
author:            geunyoung
cover:             /assets/mountain-alternative-cover.jpg
published:         true
cover:             /assets/mountain-alternative-cover.jpg
language:          KO
comments:          true
---

## 들어가기 앞서...

내가 맡은 앱에서 시스템 보안 점검이 있었는데 그곳에서 꼭 AES256에 대한 암/복호화 로직을 넣었으면 한다는 요구사항이 들어왔다.
AES128를 적용해 본 적이 있는 나로선 여느때와 같이 AES256에 대해 코딩 완료 후 로컬에서 테스트 하고 개발서버에 반영을 하였다.

갑자기 에러 발생!

로컬에서는 되는데 왜 개발에선 에러가 나는 거지???

몇 시간을 헤매다 원인을 찾았고 그런 일로 시간 낭비하지 않도록 포스팅을 진행한다.


### 소스

이전에 AES128과 크게 다를 바 없는 소스이다.

```java

public class AdapterEnDecodeUtil {
	
	public static Logger logger = LoggerFactory.getLogger(AdapterEnDecodeUtil.class);
	
	private static String secureKey =  "ADTIntegratedKeysBPCSBFPtrlzzzzz";
			
    public static String aes256decrypt(String enStr) throws BadPaddingException, IllegalBlockSizeException, NoSuchPaddingException, NoSuchAlgorithmException, InvalidAlgorithmParameterException, InvalidKeyException, UnsupportedEncodingException { 	
    	byte[] iv = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
        byte[] keyDate = secureKey.getBytes();

        SecretKey secureKey = new SecretKeySpec(keyDate, "AES"); 
        Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding");  
        c.init(Cipher.DECRYPT_MODE, secureKey, new IvParameterSpec(iv));
        
        byte[] byteStr = Base64.decodeBase64(enStr.getBytes());
        String str = new String(c.doFinal(byteStr), "UTF-8");
        
        return str;
    }

    public static String aes256encrypt(String str) throws InvalidAlgorithmParameterException, InvalidKeyException, NoSuchPaddingException, NoSuchAlgorithmException, UnsupportedEncodingException, BadPaddingException, IllegalBlockSizeException {
        byte[] iv = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
        byte[] keyDate = secureKey.getBytes();

        SecretKey secureKey = new SecretKeySpec(keyDate, "AES");
        Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding");
        c.init(Cipher.ENCRYPT_MODE, secureKey, new IvParameterSpec(iv));

        byte[] encrypted = c.doFinal(str.getBytes("UTF-8"));
        String enStr = new String(Base64.encodeBase64(encrypted));

        return enStr;
    }
}

```

### Spring Exception Handling 방식

우선 Java에서 try catch finally문을 이용하여 Exception을 잡는다는 것은 안다는 전제하에 진행하겠다.

Spring에서는 Exception에 대한 소스를 개발할때 일반적으로 3가지 정도를 생각하며 정리한다.

1. 예외별로 - Exception을 커스텀마이즈하여 그 Exception의 Error Status Code를 매핑하여 처리할 때 사용.

2. 컨트롤러별로 - Spring으로 프로젝트를 진행하다보면 기능에 따라 묶다보면 여러개의 컨트롤러가 생긴다. 컨트롤러에 따라 Excption을 처리해준다.

3. 전역별로 - 전역적으로 발생하는 예외들에 대해 처리한다.

## 자 이제 소스로 구현하는 방법을 알아보자

### 1. 예외별로

예외별 방식부터 살펴보자

예를 들어 id에 0~100사이가 아닐 시 IdFotFoundException이란 커스터마이즈된 Exception을 발생시키고 그 Exception은 RuntimeException으로 처리하고 싶다고 가정하자

```java

@ResponseStatus(value = HttpStatus.NOT_FOUND, reason = "No such order")
public class IdNotFoundException extends RuntimeException {

	/**
	 * Unique ID for Serialized object
	 */
	private static final long serialVersionUID = -6184044926029805156L;

	public IdNotFoundException(int orderId) {
		super(orderId + " not found");
	}
}

```

```java

@RestController
public class ExceptionController {

	@GetMapping(value="/checkIdValidation/{id}") 
	public String checkIdValidation(@PathVariable("id") int id) { 
		
		if (id < 0 || id > 100 ) throw new IdNotFoundException(id); 
		return "it's valid Id"; 
	}
}

```
위와 같이 생성한다면 IdNotFoundException을 통하여 404 에러를 만들 것이다. 

### 2. 컨트롤별 예외처리

@RestController를 통해 컨트롤를 만들 때, 그 안에서 @ExceptionHandler를 활용하여 해당 컨트롤러에서 일어나는 Exception들을 컨트롤하는 방식이다.


```java

@RestController
public class ExceptionController {

	@GetMapping("/localException")
	public String exception() {
		throw new IllegalStateException("Sorry!");
	}
	
	@ExceptionHandler
	public String handle(IllegalStateException e) {
		return "IllegalStateException handled!";
	}

}

```
와 같은 형식이다.

### 3. 글로벌 예외처리

따로 @RestControllerAdvice을 활용하여 @ExceptionHandler을 통해 프로젝트 전체에 일어나는 예외들을 핸들링하는 방식이다.

```java

package com.myproject.spring5.mvc.exceptions;

import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

@RestControllerAdvice
public class GlobalExceptionHandler {

	@ExceptionHandler
	public String handleBusinessException(BusinessException ex) {
		return "Handled BusinessException";
	}

}


```

```java

package com.myproject.spring5.mvc.exceptions;

import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class ExceptionController {

	@GetMapping("/global-exception")
	public String businessException() throws BusinessException {
		throw new BusinessException();
	}

}


```


## Exception Handling 하며 느낀점, 깨달았던 부분, 실수했던 부분

1. try catch 문에서 catch 구문은 순차적임을 잊지 말아야한다. 
즉, 2개의 catch문에 해당되더라도 위의 것에만 걸린다는 뜻이다.

예를 들어

```java

try{

	//로직
}catch(CustomException1 e){
	//CustomException1 발생시 로직
}catch(CustomException2 e){
	//CustomException2 발생시 로직
}

```

에서 CustomException1와 CustomException2에 해당되더라도 CustomException1의 로직만 수행된다.
그 성질을 이용해 나는 글로벌 예외로서는 Exception이나 시스템적 에러 발생시 나는 예외들을 처리하였고,
로직적 에러 등은 Exception Class를 extend하여 커스텀마이즈한 후 사용하였다.


2. catch문에서 예외가 발생하면 catch 내의 로직에서 나오는 것이지, 컨트롤러 전체에서 나오는 것이 아니다.

예를 들어, 100개의 데이터를 삽입해야하는데 그 중에 한개가 실패하더라도 나머지 데이터들에 대해 삽입이 필요한 로직을 짜고 싶으면,

```java
List<Integer> integerList;

...로직 이하 생략...

for(int i : integerList){
	try{
		...삽입로직...
	}catch(Exception e){
		logger.error(i.toString() + "를 삽입하는데 에러가 발생하였습니다.")
	}

}

```
반대로 하나라도 실패하면 안되면 

```java

List<Integer> integerList;

...로직 이하 생략...


try{
	for(int i : integerList){
		...삽입로직...
	}
}catch(Exception e){
	logger.error(i.toString() + "를 삽입하는데 에러가 발생하였습니다.")
}finally{
	...롤백로직...
}

```

와 같은 로직으로 개발한다.


3. 클라이언트에게 에러가 전달되러면 catch 문에서 다시 throw를 해야한다. 당연한 말이기도 하지만 개발에 대해 익숙치 않을때 실수를 한 부분이다.

예를 들어

```java

	public JsonNode getDetectMainInfo(Object reqBody, String trCode)
	{
		try{
		
		}catch(Exception){
		
		}
	}

```

과 같이 코딩을 하면 서버내에서만 예외가 발생함을 알 수 있고, 클라이언트나 서블릿 dispatcher는 알 수 없다. 
따라서 나는 클라이언트나 서블릿 dispatcher가 알아 차릴수 있게 코딩을 할때 아래와 같이 코딩을 하였다.

```java

	public JsonNode getDetectMainInfo(Object reqBody, String trCode)
	{
		try{
		
		}catch(Exception){
			logger.error("여기서 에러발생");
			throw new CustomException("에러코드","에러메세지");
		}
	}

```
와 같이 코딩 하였다.


