---
layout:            post
title:             "Spring - JCO를 활용하여 SAP통신하기"
menutitle:         "Spring - JCO를 활용하여 SAP통신하기"
tags:              spring
category:          Spring
author:            geunyoung
cover:             /assets/mountain-alternative-cover.jpg
published:         true
cover:             /assets/mountain-alternative-cover.jpg
language:          KO
comments:          true
---

## 들어가기 앞서...

 회사에서 들어가서 처음으로 프로젝트를 개발하게 되었는데, 해당 프로젝트에서 SAP 통신하는 부분이 있었고 RFC 정의서들을 받아서 일일이 구조체를 만들어 통신했던 기억이 있다. SAP의 수정이 잦아서 그때마다 RFC 구조체를 다시 정의해야해 정말 번거로웠다. 그러다 다른 프로젝트를 관리하면서 JCO에 대해 알게되었고 SAP 통신 및 수정에 대해 수월하게 대응하게 되었다. 아래의 링크에 샘플 및 소스 작성하였으니 참고바란다.  
 -https://github.com/rmsdud2435/Spring5-JCOSample

### SAP, ABAP, RFC, JCO, ERP, EAI란 무었일까?
  
 SAP통신을 개발 하다보면 위의 단어가 자주 등장한다. 해당 단어들에 대한 정의를 살펴보자.
 
 * ###### SAP
  >독일 솔루션 패키지 기업의 명칭으로서 주요 솔루션패키지는 ERP, HR, CRM(정보처리기사 공부할때도 정말 많이 든던 단어들이죠?ㅋㅋ) 등이 있다.  
  
 * ###### ABAP
  >그 중 ERP 솔루션에서 사용된 언어가 ABAP이다.  
  >ERP에 대해서 참고한 블로그에서는 제조업이나 물류관련한 시스템에서 사용된다고하지만 실제로 몇몇의 대기업들과 협업하다보면 단순히 여러 시스템에서 활용되는 시스템을 ERP라 부르는 곳이 많으며, SAP이 관리하는 것이 아닌 일반적 DB또한 그러하면 ERP라 부르는 기업들도 많은 것같다. 따라서 무조건 정의대로 생각하지 말고 협업을 하면서 어떤 의미로 얘기하는지 파악하고 그에 맞춰서 대응하는게 의사소통이 덜 불편할 것 같다.
  
 * ###### RFC
  > SAP과 타시스템 간에 인터페이스를 돕는 역할이 SAP PO이고, 그 안의 FUNCTION을 RFC(Remote Function Call)이라고 한다.  
  > 일반적으로 정의서를 주고 받을때 해당 단어를 많이 쓴다.

 * ###### EAI
  > 정해진 규약(프로토콜)로 직접 주고 받으면 전송실패시 대처라던지 로그 기록 등을 중립적인 위치에서 남길 수도 없고, 규약 자체도 워낙 그때그때 달라지므로, 이를 중간에서 중재하는 프로그램을 만든 게 EAI이다. 다른 시스템으로 뭔가 데이터가 왔다갔다 할 때(매개변수든, DB 데이터든) 거쳐가는 시스템이라고 보면 된다.  
  > SAP통신시 EAI를 끼는 것이 일반적이다. 

 * ###### JCO
  > 흔히들 RFC를 호출한다(RFC를 CALL한다)는 건, SAP 정보를 타시스템과 주고 받는 것을 뜻하는데 바로 이 RFC를 호출하는 걸 라이브러리로 만들어 쉽게 개발하게끔 SAP에서 제공하는것이 SAP JCO이다.  
  > SAP JCO는 프로토콜을 이용한 통신이기 때문에 각 운영체제, 더 나아가서는 CPU에도 종속이 된다. 따라서 SAP JCO를 설치하실 때에는 프로그래밍 언어의 조건 뿐만 아니라 운영체제와 하드웨어 스펙(CPU)도 고려해야한다.  
  > 실제로 세팅을 하다보면 시스템 변수를 통해 필요 jar위치를 설정하며, OS에 따라 so혹은 dll의 확장자 파일의 활용해서 적용시킨다.


### 설정시 헤매였던 부분 및 알아둬야 하는 부분들

자, 이제 본격적으로 세팅을 하면서 헤매었던 부분들에 대해 정리해보자!

 - 나는 로컬환경은 windows이기 때문에 sapjco3.jar, sapjco3.dll을 다운을 받았다.(SAP 공식 홈페이지에서 다운가능하며, 블로그 등에서도 쉽게 찾을 수 있다.  
 
 - https://mvnrepository.com/ 에서 아래와 같이 세팅하면 된다하여 세팅하였지만 에러발생.
 ```xml
		<dependency>
	 		<groupId>com.sap</groupId>
	 		<artifactId>sapjco</artifactId>
	 		<version>3.0.11</version>
		</dependency>
```
  
 - 아래의 세팅와 같은 세팅을 통해 해결
 ```xml
		<dependency>
	 		<groupId>com.sap</groupId>
	 		<artifactId>sapjco</artifactId>
	 		<version>3.0.11</version>
			<scope>system</scope>			
			<systemPath>sapjco3.jar의 jar경로</systemPath>
		</dependency>
```
  
  - jco의 클래스 사용 시, classDefNotFound가 발생. dll에서 



### @DisallowConcurrentExecution 활용하기

그런 상황을 겪고 찾은 방식이 @DisallowConcurrentExecution 어노테이션의 활용이었다. 로직을 직접구현하지 않고 어노테이션 선언만으로 중복을 방지할 수 있는 편안함이 있었지만 만약 실행시 배치가 실행되고 있으면 대기열에 추가하여 이전 배치가 끝나는 동시에 실행되어 배치 실행시간에 불규칙적이게 바뀌었으며, 현재는 간헐적으로 실행시간이 배치시간보다 길지만, 사용자들이 많아짐에 따라 과부화가 발생할 수 있다는 생각에 수정을 결심하게 되었다.


### JobExecutionContext 활용하기

마지막으로 찾은 방식이 QuartzJobBean클래스를 extentd한 executeInternal() 메소드에서 JobExecutionContext 객체를 활용하여 중복을 차단하는 것이었다. 클러스터링 시에 중복이 발생 할 수 있지만 다행히 클러스터링이 되지 않았으며, 고객이 원한 요구사항에 맞아 채택하였다.


### 정리 및 알게된 점

* Quartz 스케줄러는 시작 후 만족되는 최초 조건에 처음으로 시작
  > 즉, 배치 시간이 0/10 * * ? * * 이고 14:10:03에 시작하였다면 14:10:10에 처음으로 실행
  
* @DisallowConcurrentExecution를 통해 중복방지
  > 배치가 시작할 때, 이미 자기 자신이 실행되고 있으면, 대기열 큐에 들어가서 해당 배치가 끝나자마자 실행  
  > 즉, 0/10으로 배치돌고 작업이 13초가 걸렸다면 20초에 시작하는 것이 아닌 13초에 시작  
  > 만약 프로세스가 늘 배치시작보다 오래 걸린다면 대기열로 인해서 과부화 혹은 overflow가 발생할 수도 있을 것으로 예상  
  > 따라서, 무조건 실행이 되어야 하며 간헐적으로 배치시간보다 실행시간이 길다면 위의 어노테이션 적합
  
* QuartzJobBean클래스를 extentd한 executeInternal() 메소드에서 JobExecutionContext 객체를 활용
  > 배치가 시작할 때, 이미 자기 자신이 실행되고 있으면 실행x  
  > 과부화가 비교적 없을 것으로 추측  
  > 배치간격보다 실행간격이 길면서 과부화를 방지하고 싶으면 사용  
  > 단, 클러스터링을 통한 Quartz에선 인식을 못하여 중복 발생될 수 있음


## 참고한 블로그 및 정보

* >SAP, RFC, JCO 정의 관련  
https://derveljunit.tistory.com/102

* >SAP 관련  
https://kaizen00.tistory.com/22
