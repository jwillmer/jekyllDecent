---
layout:            post
title:             "JEUS - DataSource가 죽은 상황에서 서버 실행하기"
menutitle:         "JEUS - DataSource가 죽은 상황에서 서버 실행하기"
tags:              jeus
category:          Server
author:            geunyoung
cover:             /assets/mountain-alternative-cover.jpg
published:         true
cover:             /assets/mountain-alternative-cover.jpg
language:          KO
comments:          true
---

## 들어가기 앞서...

저번 달인 7월에 내가 맡은 프로젝트에서 정전이 발생하여 시스템이 죽은 상황이 발생하였다. 
정전을 통해 어플리케이션 서버 및 DB 서버가 다운이 되었지만 DRP(Disaster Recovery Plan)를 토대로 이용자가 불편이 없게끔 다른 쪽 시스템으로 붙게끔 잘 유도를 하였다. 
하지만 문제는 어플리케이션 서버는 살아났지만 DB서버가 죽은 상태일 때 생겼다. DRP에서의 계획은 1번 DB, 2번 DB가 존재하며 동기화가 된 상태에서 한쪽이 죽으면 다른 한쪽으로 DB connection을 맺는 형태였다. 다행히도 다른 쪽 시스템에선 이미 실행 중이라 한쪽이 다운 된 것을 판단하고 다른 쪽으로 붙었지만 다운된 시스템이 살아나면서 해당 시스템 서버를 시작하려니 다운된 DB가 존재한다며 시작조차 안되는 상황이 발생하였고 민첩하게 대응을 못하였다.   

다음번에 이런 상황이 또 생긴다면 더 민첩하게 대응하기 위해 포스팅을 남긴다.


### 수정 1

문제된 시스템은 WebtoB/JEUS 시스템이었다.

JEUS는 Default 세팅에서 시작시 DB connection을 못 맺는다면 서버실행이 안되게끔 되어 있다.
따라서 해당 세팅을 바꿔줘야 한다.



```xml

SELECT
	...이하 중략...
FROM
	...이하 중략...
WHERE 
	A = #{a, jdbcType = VARCHAR}

```

과 같은 쿼리였다.


### 해결방안

검색을 열심히 했지만 찾기 힘들었지만 결국 도움이 될만한 내용을 찾을 수 있다.
참고한 블로그는 https://dsmoon.tistory.com/entry/ibatis-%EC%BF%BC%EB%A6%AC-%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC-%EB%B0%8F-%EC%A3%BC%EC%9D%98%EC%A0%90-%EB%B3%80%EC%88%98 이다.

해당 내용을 정리하자면 

1. 리터럴 변수(${}형식)과 바인드 변수(#{}형식)이 존재

2. ibatis에서 쿼리가 실행될 때 리터럴 변수는 해당 값이 바로 복사(약간, 자바의 statc final 느낌)

3. 바인드 변수는 OraclePreparedStatment가 생성되면서 jdbcType에 맞게 변수 적용.

이며,


실행 순서는 아래와 같다

(1) SELECT NAME FROM A WHERE AGE = #{age} AND SEX = '${male}'
(2) SELECT NAME FROM A WHERE AGE = #{age} AND SEX = 'MALE'
(3) SELECT NAME FROM A WHERE AGE = ? AND SEX = 'MALE' <-- 여기서 실행 PLAN 적용
(4) oracle.jdbc.driver.OraclePreparedStatement 생성
(5) SELECT NAME FROM A WHERE AGE = '20' AND SEX = 'MALE'
(6) oracle.jdbc.driver.OraclePreparedStatement.excute() 실행

이러한 순서 때문에 바인드 변수로 쿼리를 실행시키면 범용적 플랜을 적용할 수 밖에 없으며,
실행 플랜이 달라지면서 속도 차이가 날 수 있는 것이었다.


### 현재 소스

```xml


SELECT
	...이하 중략...
FROM
	...이하 중략...
WHERE 
	A = '{a}'

```

와 같이 수정하였더니 수행 시간이 db툴과 같아졌다.
추가로 #{a, jdbcType = VARCHAR}에서 자연스럽게 처리해주는 null에 대해서는 ibatis 쿼리 실행전 java단에서 방지시켰다.

### 바인드 변수는 그럼 왜 쓸까?

바인드 변수를 사용함으로써 서버의 과부하를 줄일 수 있다.

무슨 뜻이냐면 DB 및 서버에서 캐쉬와 메모리를 할용하는데 리터럴 변수를 활용하면 해당 내용을 재사용을 한다.

예를 들면 SELECT USER_NAME WHERE T_USER WHERE USER_ID = #{user_id}가 있다면
SELECT USER_NAME WHERE T_USER WHERE USER_ID = ? 의 형태를 메모리에 올려놓고 쿼리가 불릴때마다 재사용이 된다.

예를 들면 SELECT USER_NAME WHERE T_USER WHERE USER_ID = '${user_id}'
user_id 변수가 다른 값이 들어올때마다 쿼리가 다시 빌드되어 수행된다.


### 결론

리터럴 변수를 활용하되 쿼리 최적화를 시켜도 실행속도가 마음에 안든다면 최후의 보루로 리터럴 변수를 활용하자
