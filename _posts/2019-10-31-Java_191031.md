---
layout:            post
title:             "static 변수 이해하기"
menutitle:         "static 변수 이해하기"
tags:              java
category:          Java
author:            geunyoung
cover:             /assets/mountain-alternative-cover.jpg
published:         true
language:          KO
comments:          true
---

## 들어가기 앞서...
  
이전의 나는 static에 대해서 메모리에 고정되어 값을 공유한다 정도의 개념만 가지고 있었다. 개발할때 static을 써야할 부분에 쓰지 않으면 eclipse에서 자동으로 에러를 잡아줘서 그냥 고치면서 쓰다가 갑자기 궁금증이 일어났다.  
왜 해당 위치가 static을 못쓰며 어떤 경우에 써야할까?  
  
해당 궁금증에 대해 해결하기 위해 포스팅을 진행한다.
  
### static 변수란 ?
  
#### static 변수의 정의  
  
 Java에서 Static 키워드를 사용한다는 것은 메모리에 한번 할당되어 프로그램이 종료될 때 해제되는 것을 의미한다. 이전의 프스트에서 메모리 관련하여 GC(Garbage Collector)에 대해 다뤘던 적이 있다. 그 Heap 메모리의 영역 밖에서 클래스들이 관리하지 되는 곳이 static 영역이다. 다시 말해, JVM에 올라가지 않으며 시작과 동시에 static에 대한 영역을 미리 할당된고 프로그램이 종료될 때까지 존재한다. 따라서 오히려 사용되지 않는 객체들에 대해서는 메모리의 효율이 떨어질 수도 있다.
  
<figure>
<img src="{{ "/media/img/Java/static.jpg" | absolute_url }}" />
<figcaption>출처 : https://mangkyu.tistory.com/47 </figcaption>
</figure>
  
#### static 변수의 특징
  
  * 메모리를 참조하며 공유한다.  
    > 이 말을 다시 해석하자면 메모리를 참조하기 **때문에** 공유 된다라고 보는게 더 이해하기 쉬울 것이다.  
    > 우선 알기쉽게 소스를 통해 이런 특징을 눈으로 집적확인해보자.  
    > 
    ```java 
	package com.myproject.spring5.accessmodifier;

	public class StaticTest {

		public static class classA{
			public static int staticParam = 0;
		}

		public static void main(String[] args) {
			// TODO Auto-generated method stub
			classA a = new classA();
			classA b = new classA();

			//0이 출력
			System.out.println("a.staticParam" +  ">>>>" + a.staticParam);

			b.staticParam = 7;

			//분명 b를 수정하였는데 a도 같이 7로 바뀐 것을 볼 수 있다.
			System.out.println("a.staticParam" +  ">>>>" + a.staticParam);

		}
	}
    ```
      
    > 소스와 같이 변수가 공유되는 것을 볼 수 있다.  
    > 이런 특징에는 물론 장단점이 있으며, 장점은 메모리의 활용도와 객체값에 대한 일관성이며, 실제로 개발하면서 느낀 단점으로는 예기치 못한 곳에서의 값 변경이 일어 날 수도 있다는 것이다.  
    
  * Static 변수는 클래스 변수이다.  
    > 즉, 그 외로는 static 변수로 사용할수 없다.  
    
  * 객체를 생성하지 않고도 Static 자원에 접근이 가능하다.  
    > 이것도 소스를 통해서 보면 더 이해하기 쉬운데
    > 
    ```java
	package com.myproject.spring5.accessmodifier;

	public class StaticTest2 {

		public static class classA{
			public static String staticParam = "Hello World";

			public static void print(){
				System.out.println(staticParam);
			}
		}

		public static void main(String[] args) {

			classA.print();

			/*
			 * 이미 static을 통해 메모리를 할당 받았기에
			 * 
			 * classA a = new classA();
			 * a.print();
			 * 
			 * 와 같이 사용할 필요없다.
			 */
		}
	}
    ```
  
 * ###### RFC
  > SAP과 타시스템 간에 인터페이스를 돕는 역할이 SAP PO이고, 그 안의 FUNCTION을 RFC(Remote Function Call)이라고 한다.  
  > 일반적으로 정의서를 주고 받을때 해당 단어를 많이 쓴다.

 * ###### EAI
  > 정해진 규약(프로토콜)로 직접 주고 받으면 전송실패시 대처라던지 로그 기록 등을 중립적인 위치에서 남길 수도 없고, 규약 자체도 워낙 그때그때 달라지므로, 이를 중간에서 중재하는 프로그램을 만든 게 EAI이다. 다른 시스템으로 뭔가 데이터가 왔다갔다 할 때(매개변수든, DB 데이터든) 거쳐가는 시스템이라고 보면 된다.  
  > SAP통신시 EAI를 끼는 것이 일반적이다. 

 * ###### JCO
  > 흔히들 RFC를 호출한다(RFC를 CALL한다)는 건, SAP 정보를 타시스템과 주고 받는 것을 뜻하는데 바로 이 RFC를 호출하는 걸 라이브러리로 만들어 쉽게 개발하게끔 SAP에서 제공하는것이 SAP JCO이다.  
  > SAP JCO는 프로토콜을 이용한 통신이기 때문에 각 운영체제, 더 나아가서는 CPU에도 종속이 된다. 따라서 SAP JCO를 설치하실 때에는 프로그래밍 언어의 조건 뿐만 아니라 운영체제와 하드웨어 스펙(CPU)도 고려해야한다.  
  > 실제로 세팅을 하다보면 시스템 변수를 통해 필요 jar위치를 설정하며, OS에 따라 so혹은 dll의 확장자 파일의 활용해서 적용시킨다.
  > 


### 설정시 헤매였던 부분 및 알아둬야 하는 부분들

자, 이제 본격적으로 세팅을 하면서 헤매었던 부분들에 대해 정리해보자!

 - 나는 로컬환경은 windows이기 때문에 sapjco3.jar, sapjco3.dll을 다운을 받았다.(SAP 공식 홈페이지에서 다운가능하며, 블로그 등에서도 쉽게 찾을 수 있다.  
 
 - https://mvnrepository.com/ 에서 아래와 같이 세팅하면 된다하여 세팅하였지만 에러발생.
 ```xml
		<dependency>
	 		<groupId>com.sap</groupId>
	 		<artifactId>sapjco</artifactId>
	 		<version>3.0.11</version>
		</dependency>
```
  
 - 아래의 세팅와 같은 세팅을 통해 해결
 ```xml
		<dependency>
	 		<groupId>com.sap</groupId>
	 		<artifactId>sapjco</artifactId>
	 		<version>3.0.11</version>
			<scope>system</scope>			
			<systemPath>sapjco3.jar의 jar경로</systemPath>
		</dependency>
```
  
  - jco의 클래스 사용 시, classDefNotFound가 발생. 헤맨 결과, pom.xml의 scope 태그가 문제였던 걸로 확인. 이전에 포스팅했던 내용이었는데 이걸 헤매다니...ㅠㅠ. 이전 포스팅에서 설명했듯이 scope가 system으로 설정 시, 컴파일할때 해당 jar가 빠지게 된다. 그로 인해 실행시 classDefNotFound가 발생했던 것이다.  
  
  - sapjco3의 jar 및 dll 파일에 대해 해당 프로젝트에 설정시키는 방법이 다양한데, 그 중에 인터넷에서 제일 많이 나오며 SAP 공식 홈페이지의 매뉴얼 방법은 로컬 세팅 기준으로 jar를 server의 library에 추가(tomcat일시 tomcat/bin)하고 dll을 system32에 추가하거나, 시스템 환경 변수 CLASSPATH에 세팅하는 것이다.  
  
  - 현재 로컬에서 다른 프로젝트에서도 해당 톰캣을 사용하고 다른 프로젝트에 영향을 최소화하기 위해 나는 DeployAsembly에 해당 jar추가 후, server의 configuration에 해당 경로 세팅하였다.
  <aside>
<figure>
<img src="{{ "/media/img/Spring/jco.PNG" | absolute_url }}" />>
</figure>
</aside>
  <aside>
<figure>
<img src="{{ "/media/img/Spring/jco2.PNG" | absolute_url }}" />>
</figure>
</aside>
  <aside>
<figure>
<img src="{{ "/media/img/Spring/jco3.PNG" | absolute_url }}" />>
</figure>
</aside>


## 참고한 블로그 및 정보

* >정적 변수와 메소드 관련  
https://derveljunit.tistory.com/102  
https://kaizen00.tistory.com/22 
