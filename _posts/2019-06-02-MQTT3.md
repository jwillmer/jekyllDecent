---
layout:            post
title:             "Spring/Java 기준 MQTT 소스"
menutitle:         "Spring/Java 기준 MQTT 소스"
tags:              MQTT
category:          MQTT
author:            geunyoung
cover:             /assets/mountain-alternative-cover.jpg
published:         true
cover:             /assets/mountain-alternative-cover.jpg
language:          KO
comments:          true
math:		   false
---

## 객체생성

개발자들 마다 소스 스타일이 다 다르겠지만, 나는 Publish 객체,Subscribe 객체 따로 생성하였다.

### Pusblish 빈 등록하기

```xml

	<bean id="mqttPublishConfig" class="해당 빈 클라스 경로">
		<property name="protocol" value="" />
		<property name="broker" value="IP주소" />
		<property name="port" value="포트주소" />
		<property name="clientId" value="클라이언트ID" />
		<property name="userName" value="이름" />
		<property name="userPwd" value="비밀번호" />
		<property name="sessionTimeout" value="30" />
	</bean>

	<bean id="mqttPublish" class="해당 빈 클라스 경로" init-method="init" destroy-method="disconnect">
		<constructor-arg index="0" ref="mqttPublishConfig" />
	</bean>

```

### Pusblish Java 소스

```java

public class MqttPublishConfig {

	private String broker;
	private String clientId;
	private String userName;
	private String userPwd;
	private int sessionTimeout;
	private String protocol;
	private int port;
	
	public MqttPublishConfig(){}
	
	/**
	 * @param broker broker
	 * @param clientId
	 * @param userName
	 * @param userPwd
	 * @param sessionTimeout
	 * @param protocol
	 * @param port
	 */
	public MqttPublishConfig(String broker, String clientId, String userName, String userPwd, int sessionTimeout, String protocol, int port) {
		super();
		this.broker = broker;
		this.clientId = clientId;
		this.userName = userName;
		this.userPwd = userPwd;
		this.sessionTimeout = sessionTimeout;
		this.protocol = protocol;
		this.port = port;
	}
	
	
	public String getProtocol() {
		return protocol;
	}

	public void setProtocol(String protocol) {
		this.protocol = protocol;
	}

	public int getPort() {
		return port;
	}

	public void setPort(int port) {
		this.port = port;
	}

	public int getSessionTimeout() {
		return sessionTimeout;
	}

	public void setSessionTimeout(int sessionTimeout) {
		this.sessionTimeout = sessionTimeout;
	}

	public String getBroker() {
		return broker;
	}

	public void setBroker(String broker) {
		this.broker = broker;
	}

	public String getClientId() {
		return clientId;
	}

	public void setClientId(String clientId) {
		this.clientId = clientId;
	}

	public String getUserName() {
		return userName;
	}

	public void setUserName(String userName) {
		this.userName = userName;
	}

	public String getUserPwd() {
		return userPwd;
	}

	public void setUserPwd(String userPwd) {
		this.userPwd = userPwd;
	}

	@Override
	public String toString() {
		return "MqttPublishConfig [broker=" + broker + ", clientId=" + clientId + ", userName=" + userName
				+ ", userPwd=" + userPwd + ", sessionTimeout=" + sessionTimeout + ", protocol=" + protocol + ", port="
				+ port + "]";
	}

}

```

```java

public class MqttPublish implements MqttCallback{
	private Logger logger = LoggerFactory.getLogger(this.getClass());
	 
	private String 				broker;
	private String 				clientId;
	private String 				userName;
	private	String 				userPwd;
	private	String				protocol;
	
	private MemoryPersistence 	persistence;
	private MqttConnectOptions 	connectOptions;
	private MqttAsyncClient 	client;
	
	public MqttPublish(MqttPublishConfig mqttConfig){
		this.broker 		= mqttConfig.getBroker() + ":" + mqttConfig.getPort();
		this.clientId 		= mqttConfig.getClientId();
		this.userName 		= mqttConfig.getUserName();
		this.userPwd 		= mqttConfig.getUserPwd();
		this.protocol		= mqttConfig.getProtocol();
		logger.info("publish-info : {}", mqttConfig.toString() );
	}
	
	public void init(){
		
		try {
			connectOptions = new MqttConnectOptions();
			if(userName != null && !"".equals(userName)){
				connectOptions.setUserName(this.userName);
				connectOptions.setPassword(this.userPwd.toCharArray());
				connectOptions.setMaxInflight(9999999);
				
			}
			
			
			if("SSL".equalsIgnoreCase(protocol)) {
				SSLSocketFactory ssl = SSLUtil.getSSLSocketFactory();
				connectOptions.setSocketFactory(ssl);
				if(broker.indexOf("ssl://") == -1 ){					
					broker = "ssl://" + broker;
				}
			} else if("WSS".equalsIgnoreCase(protocol)){
				SSLSocketFactory ssl = SSLUtil.getSSLSocketFactory();
				connectOptions.setSocketFactory(ssl);
				if(broker.indexOf("wss://") == -1 ){					
					broker = "wss://" + broker;
				}
			} else if("WS".equalsIgnoreCase(protocol)){
				if(broker.indexOf("ws://") == -1 ){					
					broker = "ws://" + broker;
				}
			} else{
				if(broker.indexOf(protocol+"://") == -1 ){					
					broker = protocol + "://" + broker;
				}
			}

			connectOptions.setCleanSession(true);
			this.persistence = new MemoryPersistence();
			client = new MqttAsyncClient(this.broker, this.clientId, this.persistence);
			client.setCallback(this);
			client.connect(connectOptions);
			Thread.sleep(2000);
			
		} catch(MqttException me) {
			logger.error("reason : {}", me.getReasonCode());
			logger.error("msg : {}", me.getMessage());
			logger.error("loc : {}", me.getLocalizedMessage());
			logger.error("cause : {}", me.getCause());
			logger.error("excep : {}", me);
		} catch (Exception e) {
			logger.error(e.getMessage(), e);
		} 	
	}
	
	public void disconnect(){
		 try {
			 if(client.isConnected()) {				
				 client.disconnect();
			 }
			 
			 client.close();
			 
		 } catch (MqttException e) {
			logger.error(e.getMessage(), e);
		}
	}
	
	public boolean publish(String topic, String msg, int qos) throws InterruptedException{
		
		MqttMessage message = new MqttMessage();
		
		try {
			message.setQos(qos);
			message.setPayload(msg.getBytes());
			
			if(!client.isConnected()) {
				init();
			}
			
			client.publish(topic, message);
			return true;
			
		} catch (MqttPersistenceException e) {
			logger.error(e.getMessage(), e);
		} catch (MqttException e) {
			logger.error(e.getMessage(), e);
		} 
		
		return false;
	}
	
	@Override
	public void messageArrived(String topic, MqttMessage mqttMessage) throws Exception {
		
    	String messagePayload = new String(mqttMessage.getPayload(), "UTF-8");
    	logger.debug("Message arrived : {}", messagePayload);
    	
    }
	
	@Override
	public void connectionLost(Throwable cause) {
		logger.warn("Lost Connection." + cause.getCause());

	}
	
```

### Subscribe 빈 등록

```xml

	<bean id="mqttSubscribeConfig" class="해당 빈 클라스 경로">		
		<property name="protocol" value="wss"/>
		<property name="broker" value="211.110.93.115"/>
		<property name="port" value="8083"/>
		<property name="clientId" value="Mqtt-Client-Subscriber3"/>
		<property name="userName" value="mqtt_client_sub3"/>
		<property name="userPwd" value="!adt0305"/>
		<property name="topic" value="/test/ArgentCall/#"/>
		<property name="qos" value="1"/>
		<property name="sessionTimeout" value="30"/>
		
	</bean>

	<bean id="mqttSubscribe" class="해당 빈 클라스 경로" init-method="init" destroy-method="disconnect">
		<constructor-arg index="0" ref="mqttSubscribeConfig" />
	</bean>

```

### Subscribe Java 소스

```java

public class MqttSubscribeConfig {

	private String broker;
	private String clientId;
	private String userName;
	private String userPwd;
	private String topic;
	private int qos;
	private int sessionTimeout;
	private String protocol;
	private int port;
	
	public MqttSubscribeConfig(){}
	
	public MqttSubscribeConfig(String broker, String clientId, String userName, String userPwd, String topic, int qos, int sessionTimeout, String protocol, int port) {
		super();
		this.broker = broker;
		this.clientId = clientId;
		this.userName = userName;
		this.userPwd = userPwd;
		this.topic = topic;
		this.qos = qos;
		this.sessionTimeout = sessionTimeout;
		this.protocol = protocol;
		this.port = port;
	}
	
	
	public String getProtocol() {
		return protocol;
	}

	public void setProtocol(String protocol) {
		this.protocol = protocol;
	}

	public int getPort() {
		return port;
	}

	public void setPort(int port) {
		this.port = port;
	}

	public int getSessionTimeout() {
		return sessionTimeout;
	}

	public void setSessionTimeout(int sessionTimeout) {
		this.sessionTimeout = sessionTimeout;
	}

	public String getBroker() {
		return broker;
	}

	public void setBroker(String broker) {
		this.broker = broker;
	}

	public String getClientId() {
		return clientId;
	}

	public void setClientId(String clientId) {
		this.clientId = clientId;
	}

	public String getUserName() {
		return userName;
	}

	public void setUserName(String userName) {
		this.userName = userName;
	}

	public String getUserPwd() {
		return userPwd;
	}

	public void setUserPwd(String userPwd) {
		this.userPwd = userPwd;
	}

	public String getTopic() {
		return topic;
	}

	public void setTopic(String topic) {
		this.topic = topic;
	}

	public int getQos() {
		return qos;
	}

	public void setQos(int qos) {
		this.qos = qos;
	}

	@Override
	public String toString() {
		return "MqttConfig [broker=" + broker + ", clientId=" + clientId + ", userName=" + userName + ", userPwd="
				+ userPwd + ", topic=" + topic + ", qos=" + qos + ", sessionTimeout=" + sessionTimeout + ", protocol="
				+ protocol + ", port=" + port + "]";
	}

}

```

```java

@Service
public class MqttSubscribe implements MqttCallback{
	private Logger logger = LoggerFactory.getLogger(this.getClass());

	private  	String 					broker;
	private  	String 					clientId;
	private  	String 					userName;
	private  	String 					userPwd;
	private  	String 					topic;
	private		int					qos = 0;
	private		String					protocol;
	
	@Autowired 
	private MqttSubscribeServiceImpl 		mqttCilentService;
	
	private MemoryPersistence 			persistence;
	private MqttConnectOptions 			connectOptions;
	private MqttClient 				client;
	

	
	public MqttSubscribe(MqttSubscribeConfig mqttConfig){
		//this.broker 		= mqttConfig.getBroker();
		this.broker 		= mqttConfig.getBroker() + ":" + mqttConfig.getPort();
		this.clientId 		= mqttConfig.getClientId() + "/" + UUID.randomUUID();
		this.userName 		= mqttConfig.getUserName();
		this.userPwd 		= mqttConfig.getUserPwd();
		this.topic 			= mqttConfig.getTopic();
		this.qos 			= mqttConfig.getQos();
		this.protocol		= mqttConfig.getProtocol();
		logger.info("subscriber-info : {}", mqttConfig.toString() );
	}
	
	public void init(){
		try {
			connectOptions = new MqttConnectOptions();
			if(userName != null && !"".equals(userName)){
				connectOptions.setUserName(this.userName);
				connectOptions.setPassword(this.userPwd.toCharArray());
			}
			
			if("SSL".equalsIgnoreCase(protocol)) {		
				SSLSocketFactory ssl = SSLUtil.getSSLSocketFactory();
				connectOptions.setSocketFactory(ssl);
				this.broker = "ssl://" + broker;
			} else if("WSS".equalsIgnoreCase(protocol)){
				SSLSocketFactory ssl = SSLUtil.getSSLSocketFactory();
				connectOptions.setSocketFactory(ssl);
				this.broker = "wss://" + broker;
			} else if("WS".equalsIgnoreCase(protocol)){
				this.broker = "ws://" + broker;
			}

			connectOptions.setCleanSession(true);
			this.persistence = new MemoryPersistence();
			client = new MqttClient(this.broker, this.clientId, this.persistence);
			client.setCallback(this);
			
		} catch(MqttException me) {
			logger.error("reason : {}", me.getReasonCode());
			logger.error("msg : {}", me.getMessage());
			logger.error("loc : {}", me.getLocalizedMessage());
			logger.error("cause : {}", me.getCause());
			logger.error("excep : {}", me);
		} catch (Exception e) {
			logger.error(e.getMessage(), e);
		} 
		
	}
	
	public void disconnect(){
		 try {
			 if(client.isConnected()) {
				 client.unsubscribe(topic);
				 client.disconnect();
			 }
			 
			 client.close();
			 
		 } catch (MqttException e) {
			logger.error(e.getMessage(), e);
		}
	}
	
	
	public void subscribe(){
		
		int retryCount = 0;
		while(true) {
			try {
				
				if(retryCount > 10) {
					logger.warn("Not Connected MQTT Server. topic : {}", topic);
					break;
				} else {
					if(!client.isConnected()) {
						logger.info("Try Connecting to broker : {}, connecting count : {}", this.broker, retryCount);
						retryCount++;
						
						client.connect(connectOptions);
						
						Thread.sleep(500);
					} else {
						client.subscribe(topic, qos);
						logger.info("connected topic :: {}", topic);
						break;
					}
				}
			} catch (MqttException e) {
				logger.error(e.getMessage(), e);
			} catch (InterruptedException e) {
				logger.error(e.getMessage(), e);
			} catch (Exception e) {
				logger.error(e.getMessage(), e);
			}
		}
	}
	
	@Override
	public void messageArrived(String topic, MqttMessage mqttMessage) throws Exception {
		try {
			mqttCilentService.process(topic, mqttMessage);
		} catch (DBException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
    }
	
	@Override
	public void connectionLost(Throwable cause) {
		 logger.warn("Lost Connection." + cause.getCause());	 
	}

	@Override
	public void deliveryComplete(IMqttDeliveryToken iMqttDeliveryToken) {
		logger.info("Message with " + iMqttDeliveryToken + " delivered.");
	}
	
	public boolean isLive() {
		boolean result = true;
		
		if(!client.isConnected()) {
			result = false;
			logger.info("MQTT server not Connected ! ::  Topic : {}", topic);
		} else {
			logger.trace("MQTT server Connected ! ::  Topic : {}", topic);
		}
		
		return result;
	}
}

```

### 느낀 점 및 고민했던 


