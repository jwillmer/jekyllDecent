---
layout:            post
title:             "Spring/Java 기준 MQTT 소스"
menutitle:         "Spring/Java 기준 MQTT 소스"
tags:              MQTT
category:          MQTT
author:            geunyoung
cover:             /assets/mountain-alternative-cover.jpg
published:         true
cover:             /assets/mountain-alternative-cover.jpg
language:          KO
comments:          true
math:		   false
---

## 객체생성

개발자들 마다 소스 스타일이 다 다르겠지만, 나는 Publish 객체,Subscribe 객체 따로 생성하였다.

### Pusblish 빈 등록하기

```xml

	<bean id="mqttPublishConfig" class="해당 빈 클라스 경로">
		<property name="protocol" value="wss" />
		<property name="broker" value="IP주소" />
		<property name="port" value="포트주소" />
		<property name="clientId" value="클라이언트ID" />
		<property name="userName" value="이름" />
		<property name="userPwd" value="비밀번호" />
		<property name="sessionTimeout" value="30" />
	</bean>

	<bean id="mqttPublish" class="해당 빈 클라스 경로" init-method="init" destroy-method="disconnect">
		<constructor-arg index="0" ref="mqttPublishConfig" />
	</bean>

```

### Pusblish Java 소스

```java

public class MqttPublishConfig {

	private String broker;
	private String clientId;
	private String userName;
	private String userPwd;
	private int sessionTimeout;
	private String protocol;
	private int port;
	
	public MqttPublishConfig(){}
	
	/**
	 * @param broker broker
	 * @param clientId
	 * @param userName
	 * @param userPwd
	 * @param sessionTimeout
	 * @param protocol
	 * @param port
	 */
	public MqttPublishConfig(String broker, String clientId, String userName, String userPwd, int sessionTimeout, String protocol, int port) {
		super();
		this.broker = broker;
		this.clientId = clientId;
		this.userName = userName;
		this.userPwd = userPwd;
		this.sessionTimeout = sessionTimeout;
		this.protocol = protocol;
		this.port = port;
	}
	
	
	public String getProtocol() {
		return protocol;
	}

	public void setProtocol(String protocol) {
		this.protocol = protocol;
	}

	public int getPort() {
		return port;
	}

	public void setPort(int port) {
		this.port = port;
	}

	public int getSessionTimeout() {
		return sessionTimeout;
	}

	public void setSessionTimeout(int sessionTimeout) {
		this.sessionTimeout = sessionTimeout;
	}

	public String getBroker() {
		return broker;
	}

	public void setBroker(String broker) {
		this.broker = broker;
	}

	public String getClientId() {
		return clientId;
	}

	public void setClientId(String clientId) {
		this.clientId = clientId;
	}

	public String getUserName() {
		return userName;
	}

	public void setUserName(String userName) {
		this.userName = userName;
	}

	public String getUserPwd() {
		return userPwd;
	}

	public void setUserPwd(String userPwd) {
		this.userPwd = userPwd;
	}

	@Override
	public String toString() {
		return "MqttPublishConfig [broker=" + broker + ", clientId=" + clientId + ", userName=" + userName
				+ ", userPwd=" + userPwd + ", sessionTimeout=" + sessionTimeout + ", protocol=" + protocol + ", port="
				+ port + "]";
	}

}

```

```java

public class MqttPublish implements MqttCallback{
	private Logger logger = LoggerFactory.getLogger(this.getClass());
	 
	private String 				broker;
	private String 				clientId;
	private String 				userName;
	private	String 				userPwd;
	private	String				protocol;
	
	private MemoryPersistence 	persistence;
	private MqttConnectOptions 	connectOptions;
	private MqttAsyncClient 	client;
	
	public MqttPublish(MqttPublishConfig mqttConfig){
		this.broker 		= mqttConfig.getBroker() + ":" + mqttConfig.getPort();
		this.clientId 		= mqttConfig.getClientId();
		this.userName 		= mqttConfig.getUserName();
		this.userPwd 		= mqttConfig.getUserPwd();
		this.protocol		= mqttConfig.getProtocol();
		logger.info("publish-info : {}", mqttConfig.toString() );
	}
	
	public void init(){
		
		try {
			connectOptions = new MqttConnectOptions();
			if(userName != null && !"".equals(userName)){
				connectOptions.setUserName(this.userName);
				connectOptions.setPassword(this.userPwd.toCharArray());
				connectOptions.setMaxInflight(9999999);
				
			}
			
			
			if("SSL".equalsIgnoreCase(protocol)) {
				SSLSocketFactory ssl = SSLUtil.getSSLSocketFactory();
				connectOptions.setSocketFactory(ssl);
				if(broker.indexOf("ssl://") == -1 ){					
					broker = "ssl://" + broker;
				}
			} else if("WSS".equalsIgnoreCase(protocol)){
				SSLSocketFactory ssl = SSLUtil.getSSLSocketFactory();
				connectOptions.setSocketFactory(ssl);
				if(broker.indexOf("wss://") == -1 ){					
					broker = "wss://" + broker;
				}
			} else if("WS".equalsIgnoreCase(protocol)){
				if(broker.indexOf("ws://") == -1 ){					
					broker = "ws://" + broker;
				}
			} else{
				if(broker.indexOf(protocol+"://") == -1 ){					
					broker = protocol + "://" + broker;
				}
			}

			connectOptions.setCleanSession(true);
			this.persistence = new MemoryPersistence();
			client = new MqttAsyncClient(this.broker, this.clientId, this.persistence);
			client.setCallback(this);
			client.connect(connectOptions);
			Thread.sleep(2000);
			
		} catch(MqttException me) {
			logger.error("reason : {}", me.getReasonCode());
			logger.error("msg : {}", me.getMessage());
			logger.error("loc : {}", me.getLocalizedMessage());
			logger.error("cause : {}", me.getCause());
			logger.error("excep : {}", me);
		} catch (Exception e) {
			logger.error(e.getMessage(), e);
		} 	
	}
	
	public void disconnect(){
		 try {
			 if(client.isConnected()) {				
				 client.disconnect();
			 }
			 
			 client.close();
			 
		 } catch (MqttException e) {
			logger.error(e.getMessage(), e);
		}
	}
	
	public boolean publish(String topic, String msg, int qos) throws InterruptedException{
		
		MqttMessage message = new MqttMessage();
		
		try {
			message.setQos(qos);
			message.setPayload(msg.getBytes());
			
			if(!client.isConnected()) {
				init();
			}
			
			client.publish(topic, message);
			return true;
			
		} catch (MqttPersistenceException e) {
			logger.error(e.getMessage(), e);
		} catch (MqttException e) {
			logger.error(e.getMessage(), e);
		} 
		
		return false;
	}
	
	@Override
	public void messageArrived(String topic, MqttMessage mqttMessage) throws Exception {
		
    	String messagePayload = new String(mqttMessage.getPayload(), "UTF-8");
    	logger.debug("Message arrived : {}", messagePayload);
    	
    }
	
	@Override
	public void connectionLost(Throwable cause) {
		logger.warn("Lost Connection." + cause.getCause());

	}
	
```

## 세팅

### Webserver(Apache/Tomcat) 기준 UTF-8 수정

Server의 server.xml을 아래와 같이 수정

```xml

<Connector connectionTimeout="20000" port="8080" protocol="HTTP/1.1" redirectPort="8443" URIEncoding="UTF-8"/>
<Connector port="8009" protocol="AJP/1.3" redirectPort="8443" URIEncoding="UTF-8"/>

```

### 어플리케이션 UTF-8수정

Application에 있는 web.xml을 아래와 같이 수정
 
```xml

	<filter>
    	<filter-name>encodingFilter</filter-name>
    	<filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
    	<init-param>
    	  	<param-name>encoding</param-name>
      		<param-value>UTF-8</param-value>
    	</init-param>
  	</filter>
  	<filter-mapping>
    	<filter-name>encodingFilter</filter-name>
    	<url-pattern>/*</url-pattern>
  	</filter-mapping>

```
  
### JSP수정

jsp 맨 위의 페이지에 아래 내용 추가

```jsp

<%@ page session="false" pageEncoding="UTF-8" contentType="text/html; charset=UTF-8" %>

```

### Request 프로토콜 추가(Spring 5 기준)

보통 저기 3단계까지하면 인코딩이 제대로 되었다. 근데 페이지를 redirect할 때나 값을 다시 JSP 페이지로 넘어갈때 인코딩이 안될때가 있다. 그럼 타고있는 Controller를 찾아서 UTF-8 프로토콜을 추가해준다. 

ex)

```java

@GetMapping(value = "/test", produces = "text/plain;charset=UTF-8")
public String test(@Valid JavaBean bean, BindingResult result) {
	return "hello world"
}


```
