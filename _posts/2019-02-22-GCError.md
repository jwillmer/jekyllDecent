---
layout:            post
title:             "GC(Garbage Collector) 관하여"
menutitle:         "GC(Garbage Collector) 관하여"
tags:              GC
category:          Java
author:            geunyoung
cover:             /assets/mountain-alternative-cover.jpg
published:         true
redirect_from:     "/java2/"
cover:             /assets/mountain-alternative-cover.jpg
language:          KO
comments:          true
math:		   false
---

Garbage Collector에 대해 알아보게된 계기는

시스템 운영 중인 서비스 갑자기 작동하지 않고
로그를 보려고 PUTY를 통해 계정으로 들어가려해도 access denied라는 문구가 뜨면서 들어가지지 않았다.

이 후, root계정을 통해서는 다행히 접속이 가능했고 로그를 확인해보니
java.lang.OutOfMemoryError: GC overhead limit exceeded
라는 로그가 미친듯이 쌓여있었다.

GC를 잘못 관리하면 서비스 전체가 마비될 수 있다는 것을 느끼고 알아 보게 되었다.


## GC(Garbage Collector)이란?
Java에서의 메모리 관리 방법으로 
Collect와 Flush 행위를 통해 메모리를 관리한다.
 - Collect: Heap과 Method Area라는 메모리 영역에서 사용되지 않는 Object를 모은다.
 - Flush: 이렇게 모은 Garbage들을 메모리에서 해제한다.
 
그럼 사용되지 않는 Object는 어떻게 판단할까? 
Java에서는 Root Set과의 관계로 판단한다. 즉 Root Set과 연된되지 않는 Object가 있으면 그것은 Garbage Collection 대상이 된다는 의미이다.

그럼 Root Set은 뭘로 구분할까?

Stack의 참조 정보
Local Variable Section과 Operand Stack이라는 스택 공간에 Object Reference 데이터가 있다면 이것은 Reachable Object로 판단하며 현재 Thread들이 사용하고 있는 것으로 간주한다. 즉, Garbage Collection의 입장에서는 두 스택공간이 Root Set이 되는 것이다.

Constant Pool에 있는 Reference 정보
Method Area에 로딩된 클래스(static variable이 선언된 클래스)들은 Thread들이 직접적으로 참조하고 있지 않지만 Constant Pool을 통해 간접적으로 Link하고 있는 Reachable Object이다. 그러므로 Constant Pool도 Root Set으로 볼 수 있다.

Native Method로 넘겨진 Object Reference
Native Method로 넘겨진 Object는 JNI(Java Native Interface) 형태로 현재 참조관계가 있는 Object이기 때문에 Reachable Object로 판단한다.

그림으로 보자면 아래의 파란색이 Reachable이다.
<aside>
<figure>
<img src="{{ "/media/img/Java/garbage1.png" | absolute_url }}" />
<figcaption>Reachable Object</figcaption>
</figure>
</aside>

## 경험



## 출처 및 참조

http://icednut.github.io/2018/03/25/20180325-about-java-garbage-collection/
https://d2.naver.com/helloworld/329631
