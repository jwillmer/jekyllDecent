---
layout:            post
title:             "Spring - Quartz 스케줄링에서 중복 방지하기"
menutitle:         "Spring - Quartz 스케줄링에서 중복 방지하기"
tags:              quartz1
category:          Spring
author:            geunyoung
cover:             /assets/mountain-alternative-cover.jpg
published:         true
language:          KO
comments:          true
---

## 들어가기 앞서...

 내가 시스템 관리하는 프로젝트 중에 3초 단위로 배치를 돌리는 프로세스가 존재하는데, 규모 커짐에 따라 프로세스의 실행시간이 3초가 넘어가 중복발생하는 케이스가 생겼다. 어떻게 처리할지 고민을 하다 블로그에 포스팅하게 되었으며, 샘플소스는 https://github.com/rmsdud2435/Spring5-SchedularSample 참고 바람.

### 고객의 요구사항

우선적으로, 고객이 원하는 것은 배치시간에 따라 무조건 실행되며 이미 실행이 되고 있다면, 건너뛴 후, 다음 배치때 실행되는 것이었다.


### DB를 통한 중복방지

처음으로 생각한 방식은 DB에 batch status를 저장하여 해당 batch status에서 RUNNING 상태이면, 건너뛰는 방식이었다.  
평상시에는 문제가 없었으나, 예상치 못한 부분에서 에러가 생기거나 배포를 위해 서버를 껏다키다보면 DB가 RUNNING상태에서 꺼졌다켜져서 배포 이후에 쿼리를 통하여 업데이트를 쳐야하는 번거로움있었다.


### @DisallowConcurrentExecution 활용하기

그런 상황을 겪고 찾은 방식이 @DisallowConcurrentExecution 어노테이션의 활용이었다. 로직을 직접구현하지 않고 어노테이션 선언만으로 중복을 방지할 수 있는 편안함이 있었지만 만약 실행시 배치가 실행되고 있으면 대기열에 추가하여 이전 배치가 끝나는 동시에 실행되어 배치 실행시간에 불규칙적이게 바뀌었으며, 현재는 간헐적으로 실행시간이 배치시간보다 길지만, 사용자들이 많아짐에 따라 과부화가 발생할 수 있다는 생각에 수정을 결심하게 되었다.


### JobExecutionContext 활용하기

마지막으로 찾은 방식이 QuartzJobBean클래스를 extentd한 executeInternal() 메소드에서 JobExecutionContext 객체를 활용하여 중복을 차단하는 것이었다. 클러스터링 시에 중복이 발생 할 수 있지만 다행히 클러스터링이 되지 않았으며, 고객이 원한 요구사항에 맞아 채택하였다.


### 정리 및 알게된 점

* Quartz 스케줄러는 시작 후 만족되는 최초 조건에 처음으로 시작
  > 즉, 배치 시간이 0/10 * * ? * * 이고 14:10:03에 시작하였다면 14:10:10에 처음으로 실행
  
* @DisallowConcurrentExecution를 통해 중복방지
  > 배치가 시작할 때, 이미 자기 자신이 실행되고 있으면, 대기열 큐에 들어가서 해당 배치가 끝나자마자 실행  
  > 즉, 0/10으로 배치돌고 작업이 13초가 걸렸다면 20초에 시작하는 것이 아닌 13초에 시작  
  > 만약 프로세스가 늘 배치시작보다 오래 걸린다면 대기열로 인해서 과부화 혹은 overflow가 발생할 수도 있을 것으로 예상  
  > 따라서, 무조건 실행이 되어야 하며 간헐적으로 배치시간보다 실행시간이 길다면 위의 어노테이션 적합
  
* QuartzJobBean클래스를 extentd한 executeInternal() 메소드에서 JobExecutionContext 객체를 활용
  > 배치가 시작할 때, 이미 자기 자신이 실행되고 있으면 실행x  
  > 과부화가 비교적 없을 것으로 추측  
  > 배치간격보다 실행간격이 길면서 과부화를 방지하고 싶으면 사용  
  > 단, 클러스터링을 통한 Quartz에선 인식을 못하여 중복 발생될 수 있음


